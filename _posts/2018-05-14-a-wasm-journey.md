---
layout: post
title:  A WASM Journey
date:   2018-05-14 02:00:24 +0530 
categories: WebAssembly
comments: true
tags: C++, Frontend, WebAssembly, JS Performance
---
Recently I was browsing for methods to perform compute intensive operations on the client-end browser, when I came across the awesome of WebAssembly or WASM for short. WASM is an optimized machine level executable file which can be loaded and run in the Javascript Engine of the browser. 
*P.S. If it doesn't make sense yet, just keep reading, it'll start to make sense.*      

### First, understanding how JS Engine works:
Since its inception in 1995, Javascript engine has matured a lot to cater various use cases and web specifications. WebAssembly is one of many such steps towards a more robust and better utilization of the JS Engine.     
In context of Google Chrome's v8 JS engine, there exists a couple of stages before an executable code is run on it VM.  
The v8 uses a Just-In-Time (JIT) compilation statergy which makes compilation a bit different as compared to the traditional program executions. Since JS is a dynamically typed languauge, each and every function undergoes various kinds of checks, these additional checks while execution prove to be quite expensive in terms of computational cycles.        
*Eg. A simple function to add two numbers goes long way by checking the type of operands, operators, semantics, possible methods etc. If the type of variables is string then it has to be dealt in a different way as compared to if they are numbers. Thus, these operations incur additional CPU cycles.*
```javascript
// A javascript function to add two numbers.
function addition(a, b){
    return a + b;
}
```
*Whereas, if the same code had been written in a statically typed language such as C/C++, Java or Rust, these CPU cycles could have been saved*   
```cpp
// A C/C++ function to add two numbers.
long int addition(long int a, long int b){
    return (a+b);
}
```         

See a bit of a performance problem there?       

### How does JS Engine handle it?
Apart from being a JIT, the engine is smart enough to identify the **hot** functions i.e. the functions which are used more often in the runtime.   
Such functions are then passed to the Turbo-Fan where it is optimized and converted to machine level code. Once optimization is done, on further calls, these functions can be directly invoked from their native machine level codes and executed. This makes iterative calls to functions really really fast in the JS Engine.
Diagramatically,
![v8 Pipeline architecture]({{site.baseurl}}/images/a-wasm-journey/v8-pipeline.png)  
*Ignition is v8's interpreter which generates bytecode and this is further consumed down by Turbo-Fan to produce optimized code.*

#### But there's a catch
These machine level codes generated by Turbo-Fan are statically typed for various optimization reasons. So whenever there exists a call to this function such that the *typeof* the passed arguments is different as compared to the one being used while optimization, the function undergoes deoptimization and again CPU cycles are being wasted in type checking, building Abstract Syntax Tree (AST) and so on.        

### Where does webassembly fit into all of this?
Since JS doesn't fit in really good for compute intensive operations, there was a need to somehow supply a more optimized executable to the JS engine which can be safely loaded & executed in the browsers' environment.    
asm.js tried to solve this by letting us inject intermediatary compiled code to the browser, but it came with its own set of problems.
> Webassembly is asm.js done right.
Webassembly operates on Turbo-Fan (in case of Chrome) and each of Spidermonkey, Chakra, Nitro etc have already announced Webassembly support in their recent versions.

### How webassembly works?
Webassembly is an intermediate representation of machine code which is mapped to the client-side ISA by Turbo-Fan(in case of Chrome). Thus, it doesn't have to go through the initial phases of parsing and compiling at runtime like other JS modules, it can be directly passed to the optimization engine and executed.
Diagramatically,
![webassembly injecting into v8]({{site.baseurl}}/images/a-wasm-journey/webassembly.jpg)  

### Playing around with WASM
Currently there's not a direct way to inject a wasm file into JS, we need some method calls and wrappers around to make it workable in browsers. Thanks to Emscripten, which interacts with its LLVM backend and provides a `.wasm` executable as well as a `.js` file to directly use in our web applications.

#### 1. Writing a C/C++/Rust code including emscripten headers
Recursive & Iterative factorial in C++          
```cpp
#include <emscripten/emscripten.h>

// Checks if the given environment is C++, exports the extern "C" phrase.
#ifdef __cplusplus
extern "C"
{
#endif
    // Either Add the EMSCRIPTEN_KEEPALIVE tag or while executing add to -s EXPORTED_FUNCTIONS="['_recursive_factorial']"
    EMSCRIPTEN_KEEPALIVE
    // Recursive Factorial.
    long long recursive_factorial(long long int a)
    {
        if (a <= 1)
        {
            return 1;
        }
        return a * recursive_factorial(a - 1);
    }

    EMSCRIPTEN_KEEPALIVE
    // Iterative Factorial.
    long long int iterative_factorial(long long int a)
    {
        long long int ans = 1;
        while (a > 1)
        {
            ans *= a--;
        }
        return ans;
    }

#ifdef __cplusplus
}
```

#### 2. Compiling to WASM
`em++ factorial.cpp -o factorial.js -s WASM=1 -s EXTRA_EXPORTED_RUNTIME_METHODS="['addOnPostRun']"`

#### 3. Including in HTML
```HTML
    <script src="factorial.js"></script>
    <script>
        // A Javascript
        function js_iterative_factorial(a) {
            let ans = 1;
            while (a >= 1) {
                ans *= a--;
            }
            return ans;
        }
        let iterative_factorial = Module.cwrap('iterative_factorial', 'number', ['number'])

        // When the Module object is loaded, it fires the anonymous function passed as callback.
        Module.addOnPostRun(function(){
            let num = 12;
            console.time('js_terative_factorial');
            console.log(js_iterative_factorial(num));
            console.timeEnd('js_terative_factorial');

            console.time('cpp_iterative_factorial');
            console.log(iterative_factorial(num));
            console.timeEnd('cpp_iterative_factorial');
        });
    </script>
```

That's it, on a basic level, this is a pretty good implementation of Webassembly to distinguish its benchmark from Javascript implementation.           
I got a speedup of over 4x for this code.           
Share yours!!           